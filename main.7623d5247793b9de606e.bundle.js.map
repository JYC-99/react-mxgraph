{"version":3,"file":"main.7623d5247793b9de606e.bundle.js","sources":["webpack:///./src/context/ClipboardContext.ts"],"sourcesContent":["// @ts-ignore\r\nimport * as mxGraphJs from \"mxgraph-js\";\r\nimport * as React from \"react\";\r\nimport {  ImxCell, IMxGraph } from \"../types/mxGraph\";\r\nconst {\r\n  mxUtils,\r\n  mxEvent,\r\n  mxClipboard,\r\n  mxGraphModel,\r\n  mxCodec,\r\n} = mxGraphJs;\r\n\r\nmxClipboard.cellsToString = (cells) => {\r\n  const codec = new mxCodec();\r\n  const model = new mxGraphModel();\r\n  const parent = model.getChildAt(model.getRoot(), 0);\r\n\r\n  for (const cell of cells) { model.add(parent, cell); }\r\n\r\n  return mxUtils.getXml(codec.encode(model));\r\n};\r\n\r\ninterface ICopy {\r\n  gs: number;\r\n  dx: number;\r\n  dy: number;\r\n  lastPaste: string | null;\r\n  lastPasteX: number;\r\n  lastPasteY: number;\r\n  restoreFocus: boolean;\r\n}\r\n\r\nexport interface IClipboardContext {\r\n  copy: ICopy;\r\n  textInput: HTMLTextAreaElement;\r\n  copyFunc(graph: IMxGraph, copy: ICopy, textInput: HTMLTextAreaElement): void;\r\n  copyFuncForMenu(graph: IMxGraph, copy: ICopy, textInput: HTMLTextAreaElement): void;\r\n  cutFunc(graph: IMxGraph, copy: ICopy, textInput: HTMLTextAreaElement): void;\r\n  pasteFunc(evt: ClipboardEvent, graph: IMxGraph, copy: ICopy, textInput: HTMLTextAreaElement, mouseX: number, mouseY: number): void;\r\n  pasteFuncForMenu(result: string, graph: IMxGraph, copy: ICopy, textInput: HTMLTextAreaElement, mouseX: number, mouseY: number): void;\r\n  beforeUsingClipboard(graph: IMxGraph, copy: ICopy, textInput: HTMLTextAreaElement): void;\r\n  afterUsingClipboard(graph: IMxGraph, copy: ICopy, textInput: HTMLTextAreaElement): void;\r\n}\r\n\r\nconst copyCells = (graph: IMxGraph, cells: ImxCell[], copy: ICopy, textInput: HTMLTextAreaElement) => {\r\n  if (cells.length > 0) {\r\n    const clones = graph.cloneCells(cells);\r\n\r\n    for (let i = 0; i < clones.length; i += 1) {\r\n      const state = graph.view.getState(cells[i]);\r\n      // tslint:disable-next-line: strict-type-predicates  triple-equals\r\n      if (state != null) { // must use !=\r\n        const geo = graph.getCellGeometry(clones[i]);\r\n        // tslint:disable-next-line: strict-type-predicates  triple-equals\r\n        if (geo != null && geo.relative) { // must use !=\r\n          geo.relative = false;\r\n          geo.x = state.x / state.view.scale - state.view.translate.x;\r\n          geo.y = state.y / state.view.scale - state.view.translate.y;\r\n        }\r\n      }\r\n    }\r\n    textInput.value = mxClipboard.cellsToString(clones); // mxCell => xml\r\n  }\r\n  textInput.select();\r\n  copy.lastPaste = textInput.value;\r\n};\r\n// tslint:disable-next-line: cyclomatic-complexity\r\nconst _importXml = (graph: IMxGraph, xml: XMLDocument, copy: ICopy, destX?: number, destY?: number) => {\r\n  copy.dx = copy.dx ? copy.dx : 0;\r\n  copy.dy = copy.dy ? copy.dy : 0;\r\n  let cells: ImxCell[] = [];\r\n\r\n  try {\r\n    const doc = mxUtils.parseXml(xml);\r\n    const node = doc.documentElement;\r\n\r\n    if (node !== null) {\r\n      const model = new mxGraphModel();\r\n      const codec = new mxCodec(node.ownerDocument);\r\n      codec.decode(node, model);\r\n\r\n      const childCount = model.getChildCount(model.getRoot());\r\n      const targetChildCount = graph.model.getChildCount(graph.model.getRoot());\r\n\r\n      // Merges existing layers and adds new layers\r\n      graph.model.beginUpdate();\r\n      try {\r\n        for (let i = 0; i < childCount; i += 1) {\r\n          let parent = model.getChildAt(model.getRoot(), i);\r\n          // Adds cells to existing layers if not locked\r\n          if (targetChildCount > i) {\r\n            // Inserts into active layer if only one layer is being pasted\r\n            const target = (childCount === 1) ? graph.getDefaultParent() : graph.model.getChildAt(graph.model.getRoot(), i);\r\n\r\n            if (!graph.isCellLocked(target)) {\r\n              const children = model.getChildren(parent);\r\n              const cell = graph.importCells(children,\r\n                destX ? destX - children[0].geometry.x - children[0].geometry.width / 2 : copy.dx,\r\n                destY ? destY - children[0].geometry.y - children[0].geometry.height / 2 : copy.dy,\r\n                target);\r\n              if (cell) {\r\n                cells = cells.concat(cell);\r\n              }\r\n            }\r\n          }\r\n          else {\r\n            // Delta is non cascading, needs separate move for layers\r\n            parent = graph.importCells([parent], 0, 0, graph.model.getRoot())[0];\r\n            if (parent) {\r\n              const children = graph.model.getChildren(parent);\r\n              graph.moveCells(children,\r\n                destX ? destX - children[0].geometry.x - children[0].geometry.width / 2 : copy.dx,\r\n                destY ? destY - children[0].geometry.y - children[0].geometry.height / 2 : copy.dy);\r\n              cells = cells.concat(children);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      finally {\r\n        graph.model.endUpdate();\r\n      }\r\n    }\r\n  }\r\n  catch (e) {\r\n    // alert(e);\r\n    throw e;\r\n  }\r\n  return cells;\r\n};\r\n\r\n// tslint:disable-next-line: cyclomatic-complexity\r\nconst _pasteText = (graph: IMxGraph, text: string, copy: ICopy, mouseX?: number, mouseY?: number) => {\r\n  const xml = mxUtils.trim(text);\r\n  // console.log(\"text\", text);\r\n  let destX = mouseX;\r\n  let destY = mouseY;\r\n  const x = graph.container.scrollLeft / graph.view.scale - graph.view.translate.x;\r\n  const y = graph.container.scrollTop / graph.view.scale - graph.view.translate.y;\r\n  if (xml.length > 0) {\r\n    if (destX && destY) {\r\n      if (copy.lastPasteX < destX - copy.gs || copy.lastPasteX > destX + copy.gs || copy.lastPasteY < destY - copy.gs || copy.lastPasteY >  destY + copy.gs) {\r\n        copy.lastPasteX = destX;\r\n        copy.lastPasteY = destY;\r\n      } else {\r\n        destX += copy.dx;\r\n        destY += copy.dy;\r\n      }\r\n    }\r\n    if (copy.lastPaste !== xml) {\r\n      copy.lastPaste = xml;\r\n      copy.dx = 0;\r\n      copy.dy = 0;\r\n    }\r\n    else {\r\n      copy.dx += copy.gs;\r\n      copy.dy += copy.gs;\r\n    }\r\n\r\n    // Standard paste via control-v\r\n    if (xml.substring(0, 14) === \"<mxGraphModel>\") {\r\n      const cells = _importXml(graph, xml, copy, destX, destY);\r\n      graph.setSelectionCells(cells);\r\n      graph.scrollCellToVisible(graph.getSelectionCells());\r\n    }\r\n  }\r\n};\r\nconst _extractGraphModelFromEvent = (evt: ClipboardEvent) => {\r\n  let data = null;\r\n\r\n  // tslint:disable-next-line: triple-equals strict-type-predicates\r\n  if (evt != null) {\r\n    const provider = (evt.dataTransfer) ? evt.dataTransfer : evt.clipboardData;\r\n    if (provider !== null) {\r\n      if (document.ducumentMode === 10 || document.documentMode === 11) { data = provider.getData(\"Text\"); }\r\n      else {\r\n        data = (mxUtils.indexOf(provider.types, \"text/html\") >= 0) ? provider.getData(\"text/html\") : null;\r\n        // tslint:disable-next-line: binary-expression-operand-order\r\n        if (mxUtils.indexOf(provider.types, \"text/plain\" && (data === null || data.length === 0))) {\r\n          data = provider.getData(\"text/plain\");\r\n        }\r\n      }\r\n    }\r\n\r\n  }\r\n  return data;\r\n};\r\n\r\nexport const ClipboardContext = React.createContext<IClipboardContext>({\r\n  copy: {gs: 0, dx: 0, dy: 0, lastPasteX: 0, lastPasteY: 0, lastPaste: null, restoreFocus: false},\r\n  textInput: document.createElement(\"textarea\"),\r\n  copyFunc: (graph, copy, textInput) => {\r\n    if (graph.isEnabled() && !graph.isSelectionEmpty()) {\r\n      copyCells(graph, mxUtils.sortCells(graph.model.getTopmostCells(graph.getSelectionCells())), copy, textInput);\r\n      // tslint:disable-next-line: no-console\r\n      console.log(textInput.value);\r\n      copy.dx = 0;\r\n      copy.dy = 0;\r\n    }\r\n  },\r\n  copyFuncForMenu: (graph, copy, textInput) => {\r\n    if (graph.isEnabled() && !graph.isSelectionEmpty()) {\r\n      copyCells(graph, mxUtils.sortCells(graph.model.getTopmostCells(graph.getSelectionCells())), copy, textInput);\r\n      // tslint:disable-next-line: no-console\r\n      console.log(textInput.value);\r\n      copy.dx = 0;\r\n      copy.dy = 0;\r\n    }\r\n  },\r\n  cutFunc: (graph, copy, textInput) => {\r\n    if (graph.isEnabled() && !graph.isSelectionEmpty()) {\r\n      copyCells(graph, graph.removeCells(), copy, textInput);\r\n      copy.dx = -copy.gs;\r\n      copy.dy = -copy.gs;\r\n    }\r\n  },\r\n  pasteFunc: (evt, graph, copy, textInput, mouseX, mouseY) => {\r\n    textInput.value = \" \";\r\n    if (graph.isEnabled()) {\r\n      const xml = _extractGraphModelFromEvent(evt);\r\n      // tslint:disable-next-line: no-console\r\n      if (xml !== null && xml.length > 0) {\r\n        _pasteText(graph, xml, copy, mouseX, mouseY);\r\n      }\r\n      else {\r\n        window.setTimeout(mxUtils.bind(window, () => {\r\n          _pasteText(graph, textInput.value, copy, mouseX, mouseY);\r\n        }), 0);\r\n      }\r\n    }\r\n    textInput.select();\r\n  },\r\n  pasteFuncForMenu: (result, graph, copy, textInput, mouseX, mouseY) => {\r\n    textInput.value = \" \";\r\n    if (graph.isEnabled()) {\r\n      const xml = result;\r\n      // tslint:disable-next-line: strict-type-predicates\r\n      if (xml !== null && xml.length > 0) {\r\n        _pasteText(graph, xml, copy, mouseX, mouseY);\r\n      }\r\n      else {\r\n        window.setTimeout(mxUtils.bind(window, () => {\r\n          _pasteText(graph, textInput.value, copy, mouseX, mouseY);\r\n        }), 0);\r\n      }\r\n    }\r\n    textInput.select();\r\n  },\r\n  beforeUsingClipboard: (graph, copy, textInput) => {\r\n    if (!copy.restoreFocus) {\r\n      textInput.style.position = \"absolute\";\r\n      textInput.style.left = `${(graph.container.scrollLeft + 10)}px`;\r\n      textInput.style.top = `${(graph.container.scrollTop + 10)}px`;\r\n      graph.container.appendChild(textInput);\r\n\r\n      copy.restoreFocus = true;\r\n      textInput.focus();\r\n      textInput.select();\r\n    }\r\n  },\r\n  afterUsingClipboard: (graph, copy, textInput) => {\r\n    if (copy.restoreFocus) {\r\n      copy.restoreFocus = false;\r\n      if (!graph.isEditing()) { graph.container.focus(); }\r\n      if (textInput.parentNode) { textInput.parentNode.removeChild(textInput); }\r\n    }\r\n  },\r\n});\r\n"],"mappings":"AAKA","sourceRoot":""}